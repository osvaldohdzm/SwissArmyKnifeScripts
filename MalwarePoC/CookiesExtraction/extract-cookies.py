import os
import io
import re
import csv
import sys
import json
import base64
import sqlite3
import argparse
import configparser
import datetime

# We only run on Windows
if not os.name == 'nt':
    sys.exit('This script runs only in Windows')

# python.exe -m pip install pywin32
import win32crypt
# python.exe -m pip install pycryptodomex
from Cryptodome.Cipher import AES


# Match rules
rule_host = '.*'
rule_name = '.*'
rule_value = '.*'

# Output format
output_format = 'csv'

only_count = False

# Arguments
myArgParser = argparse.ArgumentParser(description='Gimme the cookies I want! Now!')
myArgParser.add_argument('-d', '--domain', metavar='domain', type=str, help='RegExp to match cookie domain')
myArgParser.add_argument('-n', '--name', metavar='name', type=str, help='RegExp to match cookie name')
myArgParser.add_argument('-v', '--value', metavar='value', type=str, help='RegExp to match cookie value')
myArgParser.add_argument('-f', '--format', metavar='format', type=str, help='Format to export data (CSV, JSON, Netscape)')
myArgParser.add_argument('-c', '--count', action='store_true', help='Only count number of cookies found')
myArgParser.add_argument('-CookiesFile', metavar='cookies_file', type=str, help='Path to the cookies file')
myArgParser.add_argument('-LocalStateFile', metavar='local_state_file', type=str, help='Path to the Local State file')
args = myArgParser.parse_args()

# Prepare rules
if args.domain:
    rule_host = args.domain
if args.name:
    rule_name = args.name
if args.value:
    rule_value = args.value

try:
    rule_host = re.compile(rule_host)
except Exception as e:
    rule_host = re.compile('.*')
    print('Invalid host name rule. Ignored.')

try:
    rule_name = re.compile(rule_name)
except Exception as e:
    rule_name = re.compile('.*')
    print('Invalid name rule. Ignored.')

try:
    rule_value = re.compile(rule_value)
except Exception as e:
    rule_value = re.compile('.*')
    print('Invalid value rule. Ignored.')


# Get selected format
if args.format:
    output_format = args.format.lower()

if args.count:
    only_count = True

# Chromium Load State
def base_chromium_loadStateInfo(path, state_file='Local State', cookies_file='Cookies'):
    # State path 
    state = os.path.join(path, state_file)
    # Check if state exist
    if not os.path.exists(state):
        return None

    # Read state content
    content = None
    try:
        with open(state, 'r') as file:
            content = json.loads(file.read())
    except:
        return None

    # Load encryption key
    encryption_key = None
    try:
        encryption_key = base64.b64decode(content['os_crypt']['encrypted_key'])
        encryption_key = encryption_key[5:]
        encryption_key = win32crypt.CryptUnprotectData(encryption_key, None, None, None, 0)[1]
    except:
        encryption_key = None

    # Load profiles
    profiles = []
    try:
        # For each profile
        for name in content['profile']['info_cache']:
            # Check if a cookies files exists
            if os.path.exists(os.path.join(path, name, cookies_file)):
                # Add profile on the list
                profiles.append(name)
    except:
        return None

    # Return data
    return {'profiles' : profiles, 'encryption_key': encryption_key}

# Chromium Get Cookies
def base_chromium_getCookies(path, encryption_key, cookies_file='Cookies'):
    # Generate paths
    path_cookies = os.path.join(path, cookies_file)

    # Check if cookies file exist
    if not os.path.exists(path_cookies):
        return []

    # Connect to the Database
    conn = sqlite3.connect(path_cookies)
    conn.text_factory = bytes
    cursor = conn.cursor()

    # Load cookies
    cookies = []
    # Get the cookies from database
    cursor.execute('SELECT host_key, name, encrypted_value FROM cookies')

    # For each cookie
    for host_key, name, encrypted_value in cursor.fetchall():
        # Decode host and name
        host_key = host_key.decode('utf-8')
        name = name.decode('utf-8')
        # Check filters
        if rule_host.match(host_key) and rule_name.match(name):
            value = None
            # Decrypt the encrypted_value
            try:
                cursor.execute('SELECT host_key, is_secure, path, expires_utc, name, encrypted_value FROM cookies')
                cipher = AES.new(encryption_key, AES.MODE_GCM, nonce=encrypted_value[3:3+12])
                value = cipher.decrypt_and_verify(encrypted_value[3+12:-16], encrypted_value[-16:])
            except:
                value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1] or value or 0
            value = value.decode('utf-8')
            # Check filters
            if rule_value.match(value):
                cookies.append({'host': host_key, 'name': name, 'value': value})

    # Close database
    conn.close()

    # Return data
    return cookies

# Load Cookies from file
def load_cookies_from_file(cookies_file_path, encryption_key):
    # Check if cookies file exist
    if not os.path.exists(cookies_file_path):
        return []

    # Load cookies based on file extension
    cookies = []
    try:
        conn = sqlite3.connect(cookies_file_path)
        cursor = conn.cursor()
        cursor.execute('SELECT host_key, is_secure, path, expires_utc, name, encrypted_value FROM cookies')
        for row in cursor.fetchall():
            host_key, is_secure, path, expires_utc, name, encrypted_value = row
            value = None
            try:
                cipher = AES.new(encryption_key, AES.MODE_GCM, nonce=encrypted_value[3:3+12])
                value = cipher.decrypt_and_verify(encrypted_value[3+12:-16], encrypted_value[-16:])
            except:
                value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1] or value or 0
            value = value.decode('utf-8')
            #if rule_value.match(value):
            if is_secure == 1:
                secure = 'TRUE'
            else: 
                secure = 'FALSE'
            cookies.append({'host': host_key, 'secure': secure, 'path': path, 'expire': expires_utc, 'name': name, 'value': value})
        conn.close()
        return cookies
    except:
        return []

    

# Get Cookies for Google Chrome
def browser_GoogleChrome(raw=False):
    # Get cookies file path
    cookies_file_path = args.CookiesFile
    # Get Local State file path
    local_state_file_path = args.LocalStateFile

    # Check if cookies file path is provided
    if not cookies_file_path:
        return [] if raw else None

    # Check if Local State file path is provided
    if not local_state_file_path:
        return [] if raw else None

    # Check if cookies file exist
    if not os.path.exists(cookies_file_path):
        return [] if raw else None

    # Check if Local State file exist
    if not os.path.exists(local_state_file_path):
        return [] if raw else None

    

    # Load encryption key from Local State file
    encryption_key = None
    try:
        with open(local_state_file_path, 'r') as file:
            content = json.loads(file.read())
            encryption_key = base64.b64decode(content['os_crypt']['encrypted_key'])
            encryption_key = encryption_key[5:]
            encryption_key = win32crypt.CryptUnprotectData(encryption_key, None, None, None, 0)[1]
            print(f"Encryption Key: {encryption_key}")
    except:
        encryption_key = None

    # Load cookies from file
    cookies = load_cookies_from_file(cookies_file_path, encryption_key)

    # Filter cookies based on rules
    #cookies = [cookie for cookie in cookies if rule_host.match(cookie['host']) and rule_name.match(cookie['name']) and rule_value.match(cookie['value'])]

    # Return results
    return cookies if raw else {'browser' : "Google Chrome", 'cookies': cookies}

# Format output
def formatCookies(f, data, headers):
    if f == 'json':
        return json.dumps(data)
    if f == 'csv':
        output = io.StringIO()
        writer = csv.DictWriter(output, fieldnames=headers, delimiter=",", quoting=csv.QUOTE_MINIMAL)
        writer.writeheader()
        writer.writerows(data)
        return output.getvalue()
    if f == 'netscape':
        output = io.StringIO()
        output.write("# Netscape HTTP Cookie File\n")
        output.write("# http://curl.haxx.se/rfc/cookie_spec.html\n")
        output.write("# This is a generated file! Do not edit.\n\n")
        output.write("# Domain\tSubdomain\tPath\tSecure\tExpire\tName\tValue\n")
        for cookie in data:
            output.write(f"{cookie['host']}\t{str(cookie['host'].startswith('.')).upper()}\t{cookie['path']}\t{cookie['secure']}\t{cookie['expire']}\t{cookie['name']}\t{cookie['value']}\n")
        return output.getvalue()
    return data

# Gather cookies
data = []
data.append(browser_GoogleChrome())

# Remove None from list
data = [i for i in data if i]

# If counters were requested
if only_count:
    for i in range(len(data)):
        data[i]['cookies'] = len(data[i]['cookies'])
    print(formatCookies(output_format, data, ["browser", "cookies"]))

# If cookies were requested
else:
    cookies = []
    for browser in data:
        cookies += browser['cookies']

    # Get current date and time
    current_datetime = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")

    # Generate file name
    file_name = f"cookies-{current_datetime}.txt"

    # Generate file path
    file_path = os.path.join(os.getcwd(), file_name)

    # Save cookies to file
    with open(file_path, 'w') as file:
        file.write(formatCookies(output_format, cookies, ["host", "name", "value"]))

    print(f"Cookies saved to file: {file_path}")
